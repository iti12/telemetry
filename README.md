# Telemetry Aggregation System

## Overview

This project implements a simulated network telemetry aggregation system inspired by NVIDIA's UFM. It consists of two main components:

1. **Telemetry Generator**: Simulates telemetry data (bandwidth, latency, packet errors) for multiple switches and stores the data in a Redis server.
2. **Metric Web Server**: Provides a REST API to fetch telemetry data from Redis. Supports endpoints to get individual metrics or all metrics across switches.

---

## Features

- Simulated telemetry data with configurable update interval.
- Redis-based shared storage for metrics.
- Fast API responses with minimal latency.
- Basic observability: logs request latency and API activity.
- Configurable server settings (host, port, logging, Redis, etc.).

---

## Directory Structure

telemetry/
├── telemetry_generator/        # Telemetry generator server
│   ├── init.py
│   ├── main.py                 # Entrypoint for telemetry generator
│   ├── telemetry_generator.py  # TelemetryGenerator class
│   ├── server.py               # aiohttp app setup
│   ├── handlers/
│   │   └── counters.py         # CountersHandler class
├── metrics_server/
│   ├── init.py
│   ├── main.py
│   ├── server.py
│   ├── handlers/
│   │   ├── __init__.py
│   │   ├── get_metric.py
│   │   └── list_metrics.py
├── shared /            # Shared helper classes
│   ├── init.py
│   └── base_redis.py           # BaseRedisStore class
│   ├── base.py                 # BaseHandler class for latency tracking
├── config.py                   # AppConfig, ServerConfig, TelemetryConfig, RedisConfig
├── setup.py                    # Project dependencies (aiohttp, redis, pytest)
├── tests/                      # Unit tests
└── README.md

---

## Installation

1. Clone the repository:

```bash
git clone https://github.com/iti12/telemetry
cd telemetry
```

2.	Create and activate a Python virtual environment:

```bash
python3 -m venv venv
source venv/bin/activate
```
3.	Install dependencies :
```bash
pip install .
```
4. Install and Start a Redis server with brew (default host: 127.0.0.1, port: 6379):
```bash
brew install redis
brew services start redis
```

⸻

## Configuration

use config.yaml to config your

    generator_server: (host="127.0.0.1", port=9001),
    metric_server: (host="127.0.0.1", port=8080),
    telemetry: (switches=5, update_interval_seconds=10),
    logging: (level="INFO", file="/tmp/telemetry.log"),
    redis: (host="127.0.0.1", port=6379, db=0)

⸻

## Telemetry Generator


### Running the telemetry generator

```bash
python telemetry_generator/main.py
```

*	This starts generating telemetry data for all configured switches and pushes it to Redis.
*	Logs request latency and metrics information to the configured log file.
* enables REST server implementing GET http://127.0.0.1:9001/counters to retrieve all counters

⸻

### API Endpoints (for Telemetry Generator)

GET /counters

Returns CSV format: switch,metric1,metric2,...

e.g:
```bash
curl -X GET http://127.0.0.1:9001/counters
```
⸻

## Metrics server

The Metrics Server is a standalone REST service that exposes telemetry data
stored in Redis. It reads data generated by the Telemetry Generator and does
not generate telemetry itself.

### Running the Metrics Server

```bash
python -m metrics_server.main
```

### API Endpoints for the metrics server

```bash
GET /telemetry/{switch_id}/{metric}
```

```bash
curl -X GET http://127.0.0.1:8080/telemetry/
```



## Testing


* use dev install

```bash
pip install -e ".[dev]"
```

Run unit tests with:

```bash
pytest -v
```
* The tests cover handlers, Redis integration, and telemetry generation.

⸻


## Future Improvements

1. Use asyncio Redis client for high-throughput ingestion
2. Add swagger for API's
3. Add docstrings, typestring 
4. Full coverage on unit tests
5. Scaling - use kafka producer per N switches, depends on the required sampling speed. Add kafak consumers to upload messages to DB
6. DB - Use relational (Mysql) DB if we know the expected attributes. else use non relational (Mongo) DB. Use index on switch-id and last_updated.
7. Add authentication and API rate limiting


This README explains the **system architecture, usage, testing, and future improvements**.  


